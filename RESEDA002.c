#pragma config(Sensor, in1,    pwrExpBat,      sensorAnalog)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl5,  trackingwheel,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  LeftDriveE,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  RightDriveE,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, FlyEnc,         sensorQuadEncoder)
#pragma config(Motor,  port2,           DriveL1,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           DriveL2,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           Descorer,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           Fly1,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Fly2,          tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           Intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           DriveR2,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           DriveR1,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          Indexer,       tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)


#include "Vex_Competition_Includes.c"


// Custom Rolling Robots Functions
/*===========================================================
Flywheel Functions
===========================================================*/
float rpm=0;
float speed=0;
float error=0;
float FlyTarget=2400;
float ticks2;
//task flyRpm()
//{
//	float ticks1;
//	while(true){
//		SensorValue(FlyEnc) = 0;

//		wait1Msec(20); // if this  changes change rpm equation
//		ticks2=SensorValue(FlyEnc);
//		rpm=(50/3)*(ticks2);  //50/3 converts to rpm 50/3)*
//}
//}



/*===========================================================
trueSpeed Functions
===========================================================*/
/**
* Converts from output power to PWM value, in order to linearize motor output.
*
* @param power  Desired percentage of max power, between -1 and 1.
* @return PWM value that will come closest to achieving the desired percentage.
*/
int powerToPwm(float power) {
	if (power == 0) {
		return 0;
	}
	float p = fabs(power);
	if (p >= 1) {
		return 127 * sgn(power);
	}
	return ((((((((-44128.10541 * p + 178572.6802) * p - 297071.4563) * p
	+ 262520.7547) * p - 132692.6561) * p + 38464.48054) * p - 6049.717501) * p
	+ 476.2279947) * p - 1.233957961) * sgn(power);
}
//LINEAR DRIVE VARIABLES
int threshold = 15;
int speedLeft;
int speedRight;
string rightDrive= "rightDrive";
string leftDrive = "leftDrive";
//SETSPEED FUNCTION
void setSpeed(char* motorName,int speed){
	int absSpeed = powerToPwm(speed / 127.0);
	if(motorName == "rightDrive") {
		motor[DriveR1] = absSpeed;
		motor[DriveR2] = absSpeed;
	}
	else if(motorName == "leftDrive"){
		motor[DriveL1] = absSpeed;
		motor[DriveL2] = absSpeed;
	}
}
//LEFTDRIVEMOTORS FUNCTION
void leftDriveMotors(int speed){

	setSpeed("leftDrive",speed);

}

//RIGHTDRIVEMOTORS FUNCTION
void rightDriveMotors(int speed){

	setSpeed("rightDrive",speed);

}
void move(int speed, int rotate, int dime, int offset)
{

	if(speed <=0)
	{
		motor[DriveR1] = speed+offset;
		motor[DriveR2] = speed+offset;
		motor[DriveL1] = speed;
		motor[DriveL2] = speed;
	}
	else if(speed >= 0)
	{
		motor[DriveR1] = speed+offset;
		motor[DriveR2] = speed+offset;
		motor[DriveL1] = speed;
		motor[DriveL2] = speed;
	}
	while(abs(SensorValue[RightDriveE]) <= rotate){} //&& (abs(SensorValue[LeftDriveE]) <= rotate ){}
	if(speed > 0 && dime == 1)
	{
		motor[DriveR1] = 30;
		motor[DriveR2] = 30;
		motor[DriveL1] = 30;
		motor[DriveL2] = 30;
		wait1Msec(200);
		motor[DriveR1] = 0;
		motor[DriveR2] = 0;
		motor[DriveL1] = 0;
		motor[DriveL2] = 0;
	}
	else if(speed < 0 && dime == 1)
	{
		motor[DriveR1] = 30;
		motor[DriveR2] = 30;
		motor[DriveL1] = 30;
		motor[DriveL2] = 30;
		wait1Msec(200);
		motor[DriveR1] = 0;
		motor[DriveR2] = 0;
		motor[DriveL1] = 0;
		motor[DriveL2] = 0;
	}
	else if(dime ==0)
	{
		motor[DriveR1] = 0;
		motor[DriveR2] = 0;
		motor[DriveL1] = 0;
		motor[DriveL2] = 0;
	}
}
void rotate(bool right, float degrees){
	if(right == true){
		motor[DriveR1] = 127;
		motor[DriveR2] = 127;
		motor[DriveL1] = -127;
		motor[DriveL2] = -127;
		wait1Msec(3*degrees);
		motor[DriveR1] = 0;
		motor[DriveR2] = 0;
		motor[DriveL1] = 0;
		motor[DriveL2] = 0;

		}if(right == false){
		motor[DriveR1] = -127;
		motor[DriveR2] = -127;
		motor[DriveL1] = 127;
		motor[DriveL2] = 127;
		wait1Msec(3*degrees);
		motor[DriveR1] = 0;
		motor[DriveR2] = 0;
		motor[DriveL1] = 0;
		motor[DriveL2] = 0;
	}
}
void rotateL(int speed, int rotation)
{


	motor[DriveR1] = speed;
	motor[DriveR2] = speed;
	motor[DriveL1] = -speed;
	motor[DriveL2] = -speed;

	while(abs(SensorValue[RightDriveE]) <= rotation){}
	motor[DriveR1] = -20;
	motor[DriveR2] = -20;
	motor[DriveL1] = 20;
	motor[DriveL2] = 20;
	wait1Msec(100);
	motor[DriveR1] = 0;
	motor[DriveR2] = 0;
	motor[DriveL1] = 0;
	motor[DriveL2] = 0;
}

void rotateR(int speed, int rotation)
{

	motor[DriveR1] = -speed;
	motor[DriveR2] = -speed;
	motor[DriveL1] = speed;
	motor[DriveL2] = speed;

	while(abs(SensorValue[RightDriveE]) <= rotation){}
	motor[DriveR1] = -20;
	motor[DriveR2] = -20;
	motor[DriveL1] = 20;
	motor[DriveL2] = 20;
	wait1Msec(100);
	motor[DriveR1] = 0;
	motor[DriveR2] = 0;
	motor[DriveL1] = 0;
	motor[DriveL2] = 0;
}
/*===========================================================
ticks to feet functions
===========================================================*/
#define wheelDiameter            3.25  // Inches.
#define ticksPerRev              216   // Quadrature Encoder.
#define inchesToTicks(x)      ((x) * (ticksPerRev / (PI * wheelDiameter)))
#define driveDiameter         17.5  // Inches.
#define degreesToTicks(x)     inchesToTicks((x) * ((driveDiameter / 2.0) * (PI / 180.0)))
#define ticksToInches(x)      ((x) / (ticksPerRev / (PI * wheelDiameter)))
#define ticksToDegrees(x)     ticksToInches(x) / ((driveDiameter / 2.0) * (PI / 180.0))

/*==========================================================
LCD CODE
==========================================================*/
#define RED		0
#define BLUE	1

#define LEFT		0
#define RIGHT		1

#define ALLIANCE_COLOR_SCREEN		0
#define STARTING_TILE_SCREEN		1
#define BATTERY_SCREEN       		2
#define AUTONOMOUS_MENU      		3
#define CONFIRMATION_SCREEN  		4

const string autonRoutines[4] = {"Big Boi", "Smol boi", "11 point boi", "back to front... boi"};

int allianceColor = -1;
int startingTile = -1;
int autonomousRoutine = -1;

int allianceColorScreen() {
	int newScreen;

	displayLCDString(0, 0, " Alliance Color ");
	displayLCDString(1, 0, "Red   Back  Blue");

	switch (nLCDButtons) {
	case kButtonLeft:
		allianceColor = RED;
		newScreen = STARTING_TILE_SCREEN;
		break;

	case kButtonCenter:
		newScreen = BATTERY_SCREEN;
		break;

	case kButtonRight:
		allianceColor = BLUE;
		newScreen = STARTING_TILE_SCREEN;
		break;

	default:
		newScreen = ALLIANCE_COLOR_SCREEN;
		break;
	}
	while (nLCDButtons != kButtonNone) {
		wait1Msec(20);
	}
	return newScreen;
}

int startingTileScreen() {
	int newScreen;

	displayLCDString(0, 0, " Starting  Tile ");
	displayLCDString(1, 0, "Left  Back Right");

	switch (nLCDButtons) {
	case kButtonLeft:
		startingTile = LEFT;
		newScreen = AUTONOMOUS_MENU;
		break;

	case kButtonCenter:
		newScreen = ALLIANCE_COLOR_SCREEN;
		break;

	case kButtonRight:
		startingTile = RIGHT;
		newScreen = AUTONOMOUS_MENU;
		break;

	default:
		newScreen = STARTING_TILE_SCREEN;
		break;
	}
	while (nLCDButtons != kButtonNone) {
		wait1Msec(20);
	}
	return newScreen;
}

int batteryScreen() {
	int newScreen;
	string str0, str1;

	sprintf(str0, "Cortex: %.1fV    ", nAvgBatteryLevel / 1000.0);
	sprintf(str1, "PE:%.1fV  BU:%.1fV", SensorValue[pwrExpBat] / 182.4, BackupBatteryLevel / 1000.0);

	displayLCDString(0, 0, str0);
	displayLCDString(1, 0, str1);

	switch (nLCDButtons) {
	case kButtonLeft:
		newScreen = ALLIANCE_COLOR_SCREEN;
		break;

	case kButtonCenter:
		newScreen = ALLIANCE_COLOR_SCREEN;
		break;

	case kButtonRight:
		newScreen = ALLIANCE_COLOR_SCREEN;
		break;

	default:
		newScreen = BATTERY_SCREEN;
		break;
	}
	while (nLCDButtons != kButtonNone) {
		wait1Msec(20);
	}
	return newScreen;
}

int autonomousMenu() {
	const int maxAutonNum = sizeof(autonRoutines) / sizeof(autonRoutines[0]) - 1;

	int autonNum = -1;

	while (true) {
		if (autonNum == -1) {
			clearLCDLine(0);
			displayLCDString(1, 0, " <    Back    > ");
			} else {
			displayLCDCenteredString(0, autonRoutines[autonNum]);
			displayLCDString(1, 0, " <   Select   > ");
		}

		switch (nLCDButtons) {
		case kButtonLeft:
			if (autonNum == -1) {
				autonNum = maxAutonNum;
				} else {
				autonNum--;
			}
			break;

		case kButtonCenter:
			if (autonNum == -1) {
				while (nLCDButtons != kButtonNone) {
					wait1Msec(20);
				}
				return STARTING_TILE_SCREEN;
				} else {
				autonomousRoutine = autonNum;

				while (nLCDButtons != kButtonNone) {
					wait1Msec(20);
				}
				return CONFIRMATION_SCREEN;
			}
			break;

		case kButtonRight:
			if (autonNum == maxAutonNum) {
				autonNum = -1;
				} else {
				autonNum++;
			}
			break;

		default:
			break;
		}
		while (nLCDButtons != kButtonNone) {
			wait1Msec(20);
		}
		wait1Msec(20);
	}
}

int confirmationScreen() {
	int newScreen;
	string s, colorString, tileString;

	if (allianceColor == RED) {
		colorString = "Red ";
		} else {
		colorString = "Blue";
	}
	if (startingTile == LEFT) {
		tileString = " Left";
		} else {
		tileString = "Right";
	}
	sprintf(s, "%s  Back %s", colorString, tileString);

	displayLCDCenteredString(0, autonRoutines[autonomousRoutine]);
	displayLCDString(1, 0, s);

	switch (nLCDButtons) {
	case kButtonCenter:
		newScreen = AUTONOMOUS_MENU;
		break;

	default:
		newScreen = CONFIRMATION_SCREEN;
		break;
	}
	while (nLCDButtons != kButtonNone) {
		wait1Msec(20);
	}
	return newScreen;
}

task lcdTask() {
	int screenNum = BATTERY_SCREEN;

	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	while (true) {
		switch (screenNum) {
		case ALLIANCE_COLOR_SCREEN:
			screenNum = allianceColorScreen();
			break;

		case STARTING_TILE_SCREEN:
			screenNum = startingTileScreen();
			break;

		case BATTERY_SCREEN:
			screenNum = batteryScreen();
			break;

		case AUTONOMOUS_MENU:
			screenNum = autonomousMenu();
			break;

		case CONFIRMATION_SCREEN:
			screenNum = confirmationScreen();
			break;

		default:
			break;
		}
		wait1Msec(20);
	}
}
/*===========================================================
pre_auton
===========================================================*/
void pre_auton()
{
	bStopTasksBetweenModes = true;
	startTask(lcdTask);
}
/*===========================================================
Autonomous
===========================================================*/
task autonomous()
{
	if (autonomousRoutine == 0) {
		// Run Big boi.
		bool red = allianceColor == RED;
		motor[Fly1]=127;
		motor[Fly2]=127;
		wait1Msec(2000);
		motor[Fly1]=127;
		motor[Fly2]=127;
		motor[Indexer]=-127;
		motor[Intake]=-127;
		wait1Msec(1000);
		if(red == false){
			rotate(true,90);
		}
		else{
			rotate(false,90);
		}
		wait1Msec(500);
		motor[Indexer]=0;
		wait1Msec(1000);
		move(90,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		wait1Msec(500);
		move(-95,0,0,0);
		wait1Msec(1550);
		move(0,0,0,0);
		wait1Msec(500);
		if(red == false){
			rotate(false,90);
		}
		else{
			rotate(true,90);
		}
		wait1Msec(500);
		move(60,0,0,0);
		wait1Msec(1000);
		move(0,0,0,0);
		motor[Indexer] = -127;
		wait1Msec(500);
		move(60,0,0,0);
		wait1Msec(500);
		move(-120,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		wait1Msec(15000);
		} else if (autonomousRoutine == 1) {
		// Run smol boi
		motor[Fly1]=127;
		motor[Fly2]=127;
		wait1Msec(2000);
		move(60,0,0,0);
		wait1Msec(500);
		move(0,0,0,0);
		wait1Msec(500);
		motor[Fly1]=127;
		motor[Fly2]=127;
		motor[Intake]=-127;
		motor[Indexer]=-127;
		wait1Msec(1000);
		motor[Indexer]=0;
		wait1Msec(500);
		//comment here
		move(60,0,0,0);
		wait1Msec(1000);
		move(0,0,0,0);
		motor[Indexer]=127;
		wait1Msec(500);
		move(60,0,0,0);
		//comment here
		move(60,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		wait1Msec(500);
		move(-120,0,0,0);
		wait1Msec(500);
		move(0,0,0,0);
		wait1Msec(15000);
	}
	if (autonomousRoutine == 2) {
		//back auton
		motor[Intake]=127;
		move(100,0,0,0);
		wait1Msec(700);
		move(0,0,0,0);
		wait1Msec(500);
		move(-100,0,0,0);
		wait1Msec(500);
		move(0,0,0,0);
		wait1Msec(15000);
	}
	if (autonomousRoutine == 3) {
		//skills
		motor[Fly1]=127;
		motor[Fly2]=127;
		wait1Msec(2000);
		motor[Fly1]=127;
		motor[Fly2]=127;
		motor[Indexer]=-127;
		motor[Intake]=-127;
		wait1Msec(1000);
		rotate(true,90);
		wait1Msec(500);
		motor[Indexer]=0;
		wait1Msec(1000);
		move(90,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		wait1Msec(500);
		move(-95,0,0,0);
		wait1Msec(1550);
		move(0,0,0,0);
		wait1Msec(500);
		rotate(false,90);
		wait1Msec(500);
		move(60,0,0,0);
		wait1Msec(1000);
		move(0,0,0,0);
		motor[Indexer] = -127;
		wait1Msec(500);
		move(60,0,0,0);
		wait1Msec(500);
		move(-120,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		//reversing the Intake
		motor[Intake] = 127;
		//move to backwards starting square
		move(-120,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		wait1Msec(500);
		//going to knock over 2 caps
		rotate(false,90);
		move(90,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		wait1Msec(500);
		//turning around and aiming for the other 2 caps
		rotate(false,90);
		move(60,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		wait1Msec(500);
		rotate(false,90);
		wait1Msec(500);
		//hitting the other 2 caps
		move(90,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		wait1Msec(45000);}
	if (autonomousRoutine == 4) {
		wait1Msec(5000);
		move(60,0,0,0);
		wait1Msec(1500);
		move(0,0,0,0);
		motor[Fly1]=127;
		motor[Fly2]=127;
		motor[Indexer]=-127;
		motor[Intake]=-127;
		wait1Msec(1500);
		motor[Fly1]=60;
		motor[Fly2]=60;
		motor[Indexer]=-127;
		motor[Intake]=-127;
		rotate(true,90);
		wait1Msec(500);
		move(0,0,0,0);
		wait1Msec(15000);}
}
/*===========================================================
User Control
===========================================================*/
task usercontrol()
{
	datalogClear();
	SensorValue(FlyEnc) = 0;
	while (true)
	{
		speedLeft = vexRT[Ch3];
		speedRight = vexRT[Ch2];
		if (abs(speedLeft) > threshold) {
			leftDriveMotors(speedLeft);
		}
		else{
			leftDriveMotors(0);
		}
		if (abs(speedRight) > threshold) {
			rightDriveMotors(speedRight);
		}
		else{
			rightDriveMotors(0);
		}
		motor[Fly1] = 127;
		motor[Fly2] = 127;
		datalogAddValue(0,rpm);
		if(vexRT[Btn5D] == 1)
		{
			motor[Intake] = -127;
		}
		else if(vexRT[Btn5U] == 1)
		{
			motor[Intake] = 127;
		}
		else
		{
			motor[Intake] = 0;
		}
		if(vexRT[Btn6D] == 1)
		{
			motor[Indexer] = -127;
		}
		else if(vexRT[Btn6U] == 1)
		{
			motor[Indexer] = 127;
		}
		else
		{
			motor[Indexer] = 0;
		}
		if(vexRT[Btn7L] == 1){
			motor[Descorer] = -127;
			}else if(vexRT[Btn7U] == 1){
			motor[Descorer] = 127;
			}else{
			motor[Descorer] = 0;
		}
	}
}
